// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "@openzeppelin/contracts@4.9.3/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts@4.9.3/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts@4.9.3/access/Ownable.sol";
import "@openzeppelin/contracts@4.9.3/utils/Counters.sol";
import "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";

contract MyToken is ERC721, ERC721URIStorage, Ownable, AutomationCompatibleInterface {
    using Counters for Counters.Counter;

    Counters.Counter private _tokenIdCounter;

    uint public immutable interval;
    uint public lastTimeStamp;

    enum Type {
        Low, //0 => Uri
        Mid, //1 => Uri
        High //2 => Uri
    }

    mapping(uint256 => Type) nftType;

    string[] IpfsUri = [
        "https://ipfs.io/ipfs/QmS3aP9ZPfCuJsMQpwZAFUQR8dLkRi97wgFw4Bdd4jV3oF/low.json",
        "https://ipfs.io/ipfs/QmS3aP9ZPfCuJsMQpwZAFUQR8dLkRi97wgFw4Bdd4jV3oF/mid.json",
        "https://ipfs.io/ipfs/QmS3aP9ZPfCuJsMQpwZAFUQR8dLkRi97wgFw4Bdd4jV3oF/high.json"
    ];

    constructor(uint _interval) ERC721("Jordan 1", "AIRJ") {
        interval = _interval;
        lastTimeStamp = block.timestamp;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            updateAllNft();
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }


    function safeMint(address to) public onlyOwner {
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        _safeMint(to, tokenId);
        nftType[tokenId] = Type.Low;
    }

    function getTypeNft(uint _tokenId) public view returns(uint256) {
        Type typeIndex = nftType[_tokenId];
        return uint(typeIndex);
    }

    function getUriByType(uint256 _tokenId) public view returns(string memory) {
        Type typeIndex = nftType[_tokenId];
        return IpfsUri[uint(typeIndex)];
    }

    function updateType(uint256 _tokenId) public {
        uint currentType = getTypeNft(_tokenId);
        if(currentType == 0) {
            nftType[_tokenId] = Type.Mid;
        } else if(currentType == 1) {
            nftType[_tokenId] = Type.High;
        } else if(currentType == 2) {
            nftType[_tokenId] = Type.Low;
        }
    }

    function updateAllNft() public {
        uint256 counter = _tokenIdCounter.current();
        
        for (uint i = 0; i < counter; i++) 
        {
            updateType(i);
        }
    }

    // The following functions are overrides required by Solidity.

    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return getUriByType(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

}